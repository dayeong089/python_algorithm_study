# 최단 경로
## 가장 짧은 경로를 찾는 알고리즘

### 다익스트라 최단 경로 알고리즘(Dijkstra Algorithm)
* 기본적으로 그리디 알고리즘으로 분류 > 매번 가장 비용이 적은 노드를 선택하여 임의의 과정을 반복
* 특정 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘
* 음의 간선이 없을 때 정상적으로 동작
* 각 노드에 대한 현재까지의 최단 거리 정보를 1차원 리스트에 저장하며 리스트를 계속 갱신
* (1) 출발 노드 > 다른 모든 노드로의 최단 거리를 무한으로 초기화 : int(1e9)로 초기화
* (2) 방문하지 않은 노드 중 최단 거리가 가장 짧은 노드 선택
* (3) 그 노드를 거쳐서 갈 수 있는 노드까지의 거리를 확인하고 기존 리스트 값보다 작으면 값을 갱신 

### 우선순위 큐(Priority Queue)
* 우선순위가 가장 높은 데이터를 가장 먼저 삭제
* PriorityQueue 혹은 heapq 사용 가능(heapq가 더 빠르게 동작하므로 더 자주 쓰인다)
* 우선순위 큐 라이브러리에 데이터 묶음을 넣으면 첫 번째 원소를 기준으로 우선순위를 설정
* 최소 힙 : 값이 낮은 데이터가 먼저 삭제 > 파이썬은 최소 힙 구조를 기반으로 함
* 최대 힙 : 값이 큰 데이터가 먼저 삭제
* 힙 자료구조에서 단일 원소를 삽입/삭제하는 데 걸리는 시간 : O(logN) (N=데이터 개수)
* 다익스트라 알고리즘에서 현재 최단 거리가 가장 짧은 노드를 선택하기 위해 우선순위 큐를 

### 플로이드 워셜 알고리즘(Floyd-Warshall Algorithm)
* 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우
* 모든 노드에 대하여 다른 모든 노드로의 최단 거리 정보를 담아야 하므로 2차원 리스트를 사용
* 시간 복잡도 : O(N^3)
* 다이나믹 프로그래밍으로 분류
* K단계에서 K를 제외한 다른 모든 노드에 대해(예를 들어 A,B) A에서 B로 가는 최소 비용과 A에서 K를 거쳐 B로 가는 비용을 비교하여 더 작은 값으로 갱신

### 인접 행렬과 인접 리스트
* 노드의 개수가 V, 간선의 개수가 E인 그래프
* 인접 행렬 : 2차원 배열을 사용하는 방식, 메모리 공간 > O(V^2), 시간 복잡도 > O(1)
* 인접 리스트 : 리스트를 사용하는 방식, 메모리 공간 > O(E), 시간 복잡도 > O(V)
* 다익스트라 알고리즘 : 인접 리스트를 이용, 플로이드 워셜 알고리즘 : 인접 행렬을 이용
* 메모리와 시간을 염두에 두고 알고리즘을 선택해 구현
