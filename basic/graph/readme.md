# 다양한 그래프 알고리즘

## 서로소 집합 자료구조
* 서로소 집합 : 공통 원소가 없는 두 집합
* 서로소 집합 자료구조(union-find 자료구조) : 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
* union 연산 : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
* find 연산 : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산
* 일반적으로 번호가 큰 노드가 번호가 작은 노드를 간선으로 가리키도록(번호 작은 노드가 부모가 되도록) 설정
* union 연산 : 각 루트 노드를 찾아서 더 큰 노드가 더 작은 노드를 가리키도록 
* 최악의 경우 find 함수가 모든 노드를 다 확인해야 하므로 시간 복잡도가 O(V) > 경로 압축 기법을 적용하여 개선 가능
* 경로 압축 기법 > 루트 노드가 부모 노드가 되도록 > 시간 복잡도를 개선할 수 있다
* 서로소 집합은 무방향 그래프 내에서의 사이크 판별에 사용 가능 : a, b 노드의 union 연산을 수행하려고 하는데 a, b의 루트 노드가 같다면 사이클이 발생

## 신장 트리(Spanning Tree)
* 신장 트리 : 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프
* 최소 신장 트리 알고리즘 : 신장 트리 중 최소 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘 

## 크루스칼 알고리즘(Kruskal Algorithm)
* 대표적인 최소 신장 트리 알고리즘
* 가장 적은 비용으로 모든 노드를 연결
* 그리디 알고리즘으로 분류
* 간선 데이터를 정렬한 뒤, 가장 거리가 짧은 간선부터 차례대로 집합에 추가
* 단, 사이클을 발생시키는 간선(루트가 이미 동일한 집합에 포함되어 있는 경우)는 제외하고 연결
* 최종적으로 신장 트리에 포함되는 간선의 개수는 (노드의 개수-1)과 같다
* 시간 복잡도 > O(ElogE) (E=간선의 개수) > 간선을 정렬할 때의 시간 복잡도
* 서로소 집합 알고리즘의 시간 복잡도는 정렬 알고리즘의 시간 복잡도보다 작으므로 무시

## 위상 정렬(Topology Sort)
* 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때
* 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열
* 진입차수(indegree) : 특정한 노드로 들어오는 간선의 개수
* (1)진입차수가 0인 노드를 큐에 넣는다
* (2)큐가 빌때까지 > 큐에서 원소를 꺼내 간선을 제거 + 새로 진입차수가 0인 노드를 큐에 넣는다
* 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 파악
* 여러가지 답이 존재
* 노드와 간선을 모두 확인하므로 시간 복잡도 > O(V+E)
